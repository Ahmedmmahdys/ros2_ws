# Crane Panel Builder Workspace

This workspace now focuses on the RCAN (Robotic Construction Automation
Network) flow for sequencing wall and column panel pick-and-place motions for a
crane using only the IFC GUID, the panel's pick position, and the placement
target position. All orchestration runs through the RCAN servicesâ€”there is no
fallback pipeline to maintain or configure.

## Packages

- `rcan_core`: owns the message broker, Neo4j database integration, task
  allocation, node generation, robot execution simulation, and state management
  services that collectively drive the installation workflow. It now also
  exposes a command line interface for sequencing installations directly
  through RCAN.
- `rcan_nodes`: hosts the ROS 2 launch and templated node artifacts generated by
  the RCAN services during execution.

## Usage

### Build the workspace (all packages)

1. Build the workspace and source the overlay:
   ```bash
   cd /path/to/ros2_ws
   colcon build --symlink-install
   source install/setup.bash
   ```

### Configure the RCAN environment

Before submitting installation requests make sure the orchestrator can reach
your panel metadata in Neo4j. Export the connection variables expected by
`rcan_core.config`:

```bash
export RCAN_NEO4J_URI=bolt://localhost:7687
export RCAN_NEO4J_USER=neo4j
export RCAN_NEO4J_PASSWORD=secret
```

Ensure your Neo4j instance contains `Panel` nodes with the `ifcguid`,
`HookPoint`, and `TargetPosition` properties as documented in
`src/rcan_core/rcan_core/db_api.py`.

### Submit installation requests

The `rcan` command line tool issues installation requests directly through the
RCAN services. After sourcing the workspace environment:

```bash
# Request installation for a specific panel
rcan install --ifcguid X1

# Sequentially install ready panels for a host (e.g., a crane or wall section)
rcan panel-chain --host WALL_12
```

Each invocation wires the in-process broker, allocates the target panel via the
database API, renders the ROS node template, launches the node, and records the
resulting state change. Generated nodes appear under
`src/rcan_nodes/rcan_nodes/generated/` and panel statuses are persisted back to
Neo4j.

### Crane action server

The generated install nodes now command the crane through the
`ros2_actions` MoveXYZ action provided in `src/Crane`. Launch the crane
simulation and start the action server before dispatching installation
requests so that the nodes can hand off motion goals:

```bash
# In a separate shell sourced with the workspace environment
ros2 run ros2_actions moveXYZ_action
```

The RCAN nodes will drive the crane by sending a sequence of MoveXYZ goals:
approach the panel hook from above, descend to the hook height, lift to a safe
clearance, travel to the target location, and finally lower the panel into
place. Failures from the action server are reported back through the existing
`/rcan/state` channel and propagate to the RCAN state manager.

To keep the orchestrator resident for long-running sessions you can launch the
core service harness:

```bash
rcan-core
```

This sets up the broker and services so subsequent API calls within the same
process can publish install requests without additional initialization.
